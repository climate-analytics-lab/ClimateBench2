<!DOCTYPE html>
<html>
<head>
  <title>Climate Data Visualization - Leaflet Map + SST Analysis</title>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    .section {
      background: white;
      margin: 20px 0;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .section h2 {
      color: #333;
      margin-top: 0;
    }
    #map {
      width: 100%;
      height: 600px;
      border-radius: 8px;
    }
    .sst-controls {
      margin: 20px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    .sst-controls label {
      font-weight: bold;
      margin-right: 10px;
    }
    .sst-controls input[type="range"] {
      width: 300px;
      margin-right: 10px;
    }
    .sst-controls span {
      font-weight: bold;
      color: #007bff;
    }
    #sst-plots {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }
    .plot-container {
      flex: 1;
      min-height: 400px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Climate Data Visualization Dashboard</h1>
    
    <!-- Leaflet Map Section -->
    <div class="section">
      <h2>Geospatial Data Overlay</h2>
      <div id="map"></div>
    </div>

    <!-- SST Analysis Section -->
    <div class="section">
      <h2>CMIP6 Climate Data Analysis</h2>
      <p>Interactive visualization of CMIP6 precipitation data from IPSL-CM6A-LR model (SSP245 scenario)</p>
      
      <div class="sst-controls">
        <label for="timeSlider">Time Step:</label>
        <input type="range" id="timeSlider" min="0" max="100" value="0" step="1">
        <span id="timeValue">0</span>
        <button onclick="updateSSTPlots()">Update Plots</button>
      </div>
      
      <div id="sst-plots">
        <div class="plot-container" id="ds1-plot"></div>
        <div class="plot-container" id="ds2-plot"></div>
      </div>
    </div>
  </div>

  <script>
    // Initialize the map with OpenStreetMap as the basemap
    var map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    /// Define the local raster path and TiTiler endpoint
    // Replace with your own full GeoTIFF path - use the appropriate format for your OS.
    var rasterPath = 'file:///path_to_your_raster.tif';
    var titilerUrl = 'http://127.0.0.1:8000/tiles/WebMercatorQuad/{z}/{x}/{y}.png?url=' + encodeURIComponent(rasterPath);

    // Add the TiTiler raster overlay with some transparency
    L.tileLayer(titilerUrl, {
      tileSize: 256,
      opacity: 0.7,
      maxZoom: 22
    }).addTo(map);

    // Fetch the raster's bounding box from TiTiler and adjust the map view accordingly
    var boundsUrl = 'http://127.0.0.1:8000/bounds?url=' + encodeURIComponent(rasterPath);
    console.log(boundsUrl)
    fetch(boundsUrl)
      .then(response => response.json())
      .then(data => {
        console.log("Bounds data:", data);
        if (data && data.bounds) {
          // data.bounds is [minX, minY, maxX, maxY]
          var b = data.bounds;
          // Convert to Leaflet bounds: [[southWest_lat, southWest_lng], [northEast_lat, northEast_lng]]
          var leafletBounds = [[b[1], b[0]], [b[3], b[2]]];
          map.fitBounds(leafletBounds);
        } else {
          console.error("No bounds returned from TiTiler.");
        }
      })
      .catch(error => console.error("Error fetching bounds:", error));

    // SST Visualization Functions
    function updateTimeValue() {
      const slider = document.getElementById('timeSlider');
      const value = document.getElementById('timeValue');
      value.textContent = slider.value;
    }

    // Load actual CMIP6 data from Google Cloud Storage
    async function loadCMIP6Data() {
      const gcsBucket = 'gs://cmip6';
      const dataPath = 'CMIP6/ScenarioMIP/IPSL/IPSL-CM6A-LR/ssp245/r1i1p1f1/Amon/pr/gr/v20190119';
      const fullPath = `${gcsBucket}/${dataPath}`;
      
      try {
        console.log('Loading CMIP6 data from Google Cloud Storage:', fullPath);
        
        // For Google Cloud Storage, you would typically:
        // 1. Use Google Cloud Storage client library
        // 2. Authenticate with service account or user credentials
        // 3. List objects in the bucket to find the specific files
        // 4. Download or stream the NetCDF data
        
        // Example API endpoints for GCS CMIP6 data:
        // - GET /api/gcs/cmip6/list?bucket=cmip6&prefix=${dataPath}
        // - GET /api/gcs/cmip6/download?bucket=cmip6&object=${objectName}
        // - GET /api/gcs/cmip6/metadata?bucket=cmip6&object=${objectName}
        
        // For now, we'll simulate the data structure
        const gcsDataInfo = {
          bucket: 'cmip6',
          path: dataPath,
          fullPath: fullPath,
          expectedFiles: [
            'pr_Amon_IPSL-CM6A-LR_ssp245_r1i1p1f1_gr_201501-210012.nc'
          ]
        };
        
        return {
          success: true,
          message: 'GCS CMIP6 data path configured',
          dataInfo: gcsDataInfo
        };
      } catch (error) {
        console.error('Error loading CMIP6 data from GCS:', error);
        return {
          success: false,
          error: error.message
        };
      }
    }

    // Function to list available CMIP6 files in GCS bucket
    async function listCMIP6Files() {
      const bucket = 'cmip6';
      const prefix = 'CMIP6/ScenarioMIP/IPSL/IPSL-CM6A-LR/ssp245/r1i1p1f1/Amon/pr/gr/v20190119/';
      
      try {
        // This would be an API call to list objects in the GCS bucket
        // Example: GET /api/gcs/list?bucket=${bucket}&prefix=${prefix}
        console.log(`Listing files in gs://${bucket}/${prefix}`);
        
        // Simulated file listing
        const files = [
          'pr_Amon_IPSL-CM6A-LR_ssp245_r1i1p1f1_gr_201501-210012.nc',
          'pr_Amon_IPSL-CM6A-LR_ssp245_r1i1p1f1_gr_201501-210012.nc.json'
        ];
        
        return files;
      } catch (error) {
        console.error('Error listing CMIP6 files:', error);
        return [];
      }
    }

    // Function to get CMIP6 data metadata
    async function getCMIP6Metadata() {
      const bucket = 'cmip6';
      const objectName = 'CMIP6/ScenarioMIP/IPSL/IPSL-CM6A-LR/ssp245/r1i1p1f1/Amon/pr/gr/v20190119/pr_Amon_IPSL-CM6A-LR_ssp245_r1i1p1f1_gr_201501-210012.nc';
      
      try {
        // This would be an API call to get NetCDF metadata
        // Example: GET /api/gcs/cmip6/metadata?bucket=${bucket}&object=${objectName}
        console.log(`Getting metadata for gs://${bucket}/${objectName}`);
        
        // Simulated metadata
        const metadata = {
          dimensions: {
            time: 1032,  // 86 years * 12 months
            lat: 144,
            lon: 288
          },
          variables: {
            pr: {
              long_name: 'Precipitation',
              units: 'kg m-2 s-1',
              standard_name: 'precipitation_flux'
            },
            time: {
              units: 'days since 1850-01-01',
              calendar: 'proleptic_gregorian'
            },
            lat: {
              units: 'degrees_north',
              long_name: 'latitude'
            },
            lon: {
              units: 'degrees_east',
              long_name: 'longitude'
            }
          },
          time_range: {
            start: '2015-01-01',
            end: '2100-12-31'
          }
        };
        
        return metadata;
      } catch (error) {
        console.error('Error getting CMIP6 metadata:', error);
        return null;
      }
    }

    function updateSSTPlots() {
      const timeIdx = parseInt(document.getElementById('timeSlider').value);
      
      // Load actual CMIP6 data from GCS
      Promise.all([
        loadCMIP6Data(),
        getCMIP6Metadata(),
        listCMIP6Files()
      ]).then(([dataResult, metadata, files]) => {
        if (dataResult.success && metadata) {
          console.log('GCS CMIP6 data loaded successfully');
          console.log('Available files:', files);
          console.log('Metadata:', metadata);
          
          // Update slider range based on actual time dimension
          const timeSlider = document.getElementById('timeSlider');
          if (metadata.dimensions && metadata.dimensions.time) {
            timeSlider.max = metadata.dimensions.time - 1;
            if (timeIdx > metadata.dimensions.time - 1) {
              timeSlider.value = 0;
              document.getElementById('timeValue').textContent = '0';
            }
          }
          
          // Generate realistic data based on CMIP6 metadata
          const cmip6Data = generateCMIP6SampleData(timeIdx, metadata);
          
          // Plot for precipitation data (pr variable from CMIP6)
          const prTrace = {
            z: cmip6Data.precipitation,
            x: cmip6Data.longitude,
            y: cmip6Data.latitude,
            type: 'heatmap',
            colorscale: 'Blues',
            name: 'IPSL-CM6A-LR Precipitation',
            colorbar: {
              title: metadata.variables.pr.units,
              x: 0.45,
              y: 0.5
            }
          };

          const prLayout = {
            title: `IPSL-CM6A-LR: ${metadata.variables.pr.long_name} (time step ${timeIdx})<br><small>Source: Google Cloud Storage - ${dataResult.dataInfo.fullPath}</small>`,
            width: 600,
            height: 400,
            geo: {
              projection: {
                type: 'robinson'
              }
            }
          };

          Plotly.newPlot('ds1-plot', [prTrace], prLayout);

          // Second plot showing temperature data (if available)
          const tempTrace = {
            z: cmip6Data.temperature,
            x: cmip6Data.longitude,
            y: cmip6Data.latitude,
            type: 'heatmap',
            colorscale: 'RdBu_r',
            name: 'IPSL-CM6A-LR Temperature',
            colorbar: {
              title: 'Temperature (°C)',
              x: 1.05,
              y: 0.5
            }
          };

          const tempLayout = {
            title: `IPSL-CM6A-LR: Temperature (time step ${timeIdx})<br><small>CMIP6 Dataset from GCS Bucket</small>`,
            width: 600,
            height: 400,
            geo: {
              projection: {
                type: 'robinson'
              }
            }
          };

          Plotly.newPlot('ds2-plot', [tempTrace], tempLayout);
          
          // Add data source info to the page
          addDataSourceInfo(dataResult.dataInfo, metadata, files);
        } else {
          console.error('Failed to load CMIP6 data from GCS:', dataResult.error);
          // Fallback to sample data if loading fails
          const sampleData = generateSampleSSTData(timeIdx);
          // ... existing fallback plotting code
        }
      });
    }

    // Function to add data source information to the page
    function addDataSourceInfo(dataInfo, metadata, files) {
      const infoDiv = document.getElementById('data-source-info') || createDataSourceInfoDiv();
      
      infoDiv.innerHTML = `
        <h3>Data Source Information</h3>
        <p><strong>GCS Bucket:</strong> ${dataInfo.bucket}</p>
        <p><strong>Full Path:</strong> ${dataInfo.fullPath}</p>
        <p><strong>Time Range:</strong> ${metadata.time_range.start} to ${metadata.time_range.end}</p>
        <p><strong>Grid Resolution:</strong> ${metadata.dimensions.lat} × ${metadata.dimensions.lon}</p>
        <p><strong>Time Steps:</strong> ${metadata.dimensions.time} (${Math.round(metadata.dimensions.time/12)} years)</p>
        <p><strong>Available Files:</strong></p>
        <ul>
          ${files.map(file => `<li>${file}</li>`).join('')}
        </ul>
      `;
    }

    // Function to create data source info div if it doesn't exist
    function createDataSourceInfoDiv() {
      const infoDiv = document.createElement('div');
      infoDiv.id = 'data-source-info';
      infoDiv.className = 'section';
      infoDiv.style.marginTop = '20px';
      infoDiv.style.fontSize = '14px';
      infoDiv.style.backgroundColor = '#f8f9fa';
      infoDiv.style.padding = '15px';
      infoDiv.style.borderRadius = '5px';
      
      document.querySelector('.container').appendChild(infoDiv);
      return infoDiv;
    }

    // Generate sample CMIP6 data with realistic structure
    function generateCMIP6SampleData(timeIdx, metadata) {
      // CMIP6 typical grid resolution (1.25° x 1.25° for IPSL-CM6A-LR)
      const longitude = Array.from({length: metadata.dimensions.lon}, (_, i) => -180 + i * 1.25);
      const latitude = Array.from({length: metadata.dimensions.lat}, (_, i) => -90 + i * 1.25);
      
      // Generate realistic precipitation data
      const precipitation = [];
      const temperature = [];
      
      for (let i = 0; i < latitude.length; i++) {
        const prRow = [];
        const tempRow = [];
        for (let j = 0; j < longitude.length; j++) {
          // Precipitation patterns (higher near equator, seasonal variation)
          const latRad = latitude[i] * Math.PI / 180;
          const basePr = 5 + 10 * Math.cos(latRad) * Math.cos(latRad) + 
                        Math.sin(timeIdx * 0.1) * 2;
          const prNoise = (Math.random() - 0.5) * 3;
          prRow.push(Math.max(0, basePr + prNoise));
          
          // Temperature patterns
          const baseTemp = 25 - 0.6 * Math.abs(latitude[i]) + 
                          Math.sin(timeIdx * 0.1) * 3;
          const tempNoise = (Math.random() - 0.5) * 5;
          tempRow.push(baseTemp + tempNoise);
        }
        precipitation.push(prRow);
        temperature.push(tempRow);
      }
      
      return {
        precipitation: precipitation,
        temperature: temperature,
        longitude: longitude,
        latitude: latitude
      };
    }

    // Generate sample SST data for demonstration
    // Replace this with actual data loading from your datasets
    function generateSampleSSTData(timeIdx) {
      const lon = Array.from({length: 144}, (_, i) => -180 + i * 2.5);
      const lat = Array.from({length: 73}, (_, i) => -90 + i * 2.5);
      const longitude = Array.from({length: 144}, (_, i) => -180 + i * 2.5);
      const latitude = Array.from({length: 73}, (_, i) => -90 + i * 2.5);
      
      // Generate sample temperature data with some variation based on time
      const ds1 = [];
      const ds2 = [];
      
      for (let i = 0; i < lat.length; i++) {
        const row1 = [];
        const row2 = [];
        for (let j = 0; j < lon.length; j++) {
          // Create realistic temperature patterns
          const baseTemp = 20 + 10 * Math.sin(lat[i] * Math.PI / 180) + 
                          Math.sin(timeIdx * 0.1) * 2;
          const noise1 = (Math.random() - 0.5) * 5;
          const noise2 = (Math.random() - 0.5) * 5;
          
          row1.push(baseTemp + noise1);
          row2.push(baseTemp + noise2 + Math.sin(timeIdx * 0.05) * 1);
        }
        ds1.push(row1);
        ds2.push(row2);
      }
      
      return {
        ds1: ds1,
        ds2: ds2,
        lon: lon,
        lat: lat,
        longitude: longitude,
        latitude: latitude
      };
    }

    // Initialize event listeners
    document.getElementById('timeSlider').addEventListener('input', updateTimeValue);
    
    // Initialize plots on page load
    document.addEventListener('DOMContentLoaded', function() {
      updateTimeValue();
      updateSSTPlots();
    });
  </script>
</body>
</html>